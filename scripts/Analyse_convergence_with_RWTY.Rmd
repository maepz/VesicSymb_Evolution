---
title: "RWTY tutorial"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
```

This script is based on tutorials:
Tuto from "https://cran.r-project.org/web/packages/rwty/vignettes/rwty.html"
Tuto from "http://danwarren.net/plot-comparisons.html" <3
# Introduction


A unique issue to mcmc searches is that it is difficult to tell how long of a chain is long enough

Key is to diagnose CONVERGENCE, point in a Markov chain where parameter estimates reach a stationary distribution, meaning that they have settled into a single region of parameter space.
Portions of the chain prior to convergence are discarded as BURNIN
Posterior parameter estimates are drawn from sampling values from thechain AFTER convergence. Setting burnin too early results in biased or poorly resolved topology and parameter estimates

Many phylogenetic mcmc packages initiate multiple independent mcmc runs

Provides added confidence in parameter estimates if these independent runs all converge on similar regions of parameter space

Many ways phylogenetic mcmc can go wrong:
 Poor Mixing
 Chains get stuck in local optima
 Sampling too frequently (values too autocorrelated)
 Failure to Converge
 Flat likelihood space
MOST COMMON: Chains are not given enough time to converge

rwty - designed to assist in the evaluation of mcmc

RWTY works with lists of rwty.chain objects. Each rwty.chain object contains outputs from a single Bayesian phylogenetic MCMC analysis, e.g. from BEAST or MrBayes. A rwty.chain object must contain the tree topologies from the chain (e.g. from the .t file from MrBayes), and can optionally contain the continuous parameters as well (e.g. from the .p file from MrBayes). 

# Installation
```{r}
# check if rwty is installed and if not, install it
if (!("rwty" %in% installed.packages())){
  install.packages("rwty", dependencies = TRUE)
}

#load rwty and dependencies
library(rwty)
```

# Load data

load.multi()
This function is used to load more than one chain into a list of rwty.chains objects. It allows you to specify the format of your MCMC analysis, so that it can automatically find tree and log files. You provide a path to the folder containing the tree files, as well as the file format (default is MrBayes). As with load.trees, load.multi will attempt to automatically find log files. For example, to search a directory named PATH for output of a MrBayes run, you would input the following:

```{r}
PATH='/Users/maeperez/Desktop/MyBayes_Bucky/Params_0'
PATH1='/Users/maeperez/Desktop/MyBayes_Bucky/Params_5_badASDSF/'
PATH2='/Users/maeperez/Desktop/MyBayes_Bucky/Params_5_badASDSF/1tree_every_500gens/'
PATH3='/Users/maeperez/Desktop/MyBayes_Bucky/Params_5_badASDSF/1tree_every_500gens/5M_gens/'
PATH4='/Users/maeperez/Desktop/MyBayes_Bucky/Params_5_badASDSF/1tree_every_500gens/1M_gens_4runs/'
PATH5='/Users/maeperez/Desktop/MyBayes_Bucky/Params_5_badASDSF/1_tree_every_10kgens/2M_gens_4runs/'

PATH20='/Users/maeperez/Desktop/MyBayes_Bucky/test_Params_20'


my.trees <- load.multi(PATH, format = "mb") # 2 runs - 0.3M - 1/10 trees gene001 
my.trees19 <- load.multi('/Users/maeperez/Desktop/MyBayes_Bucky/Params_5_badASDSF/Rmag19/', format = "mb")# 2 runs - 0.5M - 1/10 trees gene001 

my.trees1 <- load.multi(PATH1, format = "mb") # 2 runs - 0.5M - 1/10 trees --> 100000 1000 burnin
my.trees2 <- load.multi(PATH2, format = "mb") # 2 runs - 0.5M - 1/500 trees --> 2000 trees 20 burnin
my.trees3 <- load.multi(PATH3, format = "mb") # 2 runs - 5M - 1/500 trees --> 20000trees 200burnin
my.trees4 <- load.multi(PATH4, format = "mb") # 4 runs - 1M - 1/500 trees --> 8000trees 200burnin
my.trees5 <- load.multi(PATH5, format = "mb") # 4 runs - 2M - 1/10k trees --> 800trees 10burnin

my.trees003 <- load.multi('/Users/maeperez/Desktop/MyBayes_Bucky/Params_3/', format = "mb")# 2 runs - 0.3M - 1/10 trees gene001 

my.trees020 <- load.multi('/Users/maeperez/Desktop/MyBayes_Bucky/test_Params_20', format = "mb") 
my.trees020LCB=load.multi('/Users/maeperez/Desktop/MyBayes_Bucky/test_Params_20/LCB', format = "mb") 
```

preloaded data:
```{r}
# four loci, 2 runs each
data(salamanders)
names(salamanders)
# reduce to single locus with 2 runs for comparison to fugus
salamanders.amotl <- list(salamanders[[1]], salamanders[[2]])
head(salamanders.amotl)
```

# General parameter trace plots
plot and calculate Effective Sample Size (lagged autocorrelation) for params estimated by model. Phylo models can include 10s of params
This is equivalent to looking at Trace plots in Tracer

```{r echo=FALSE}

# plot LnL without burnin - variation obscured
makeplot.param(salamanders.amotl, burnin = 0, "LnL")


makeplot.param(my.trees, burnin = 0, "LnL") # doesnt work if no '.p' file
lnl1<-makeplot.param(my.trees1, burnin = 0, "LnL") # doesnt work if no '.p' file
lnl2<-makeplot.param(my.trees2, burnin = 0, "LnL") # doesnt work if no '.p' file
lnl3<-makeplot.param(my.trees3, burnin = 0, "LnL") # doesnt work if no '.p' file
lnl4<-makeplot.param(my.trees4, burnin = 0, "LnL") # doesnt work if no '.p' file
lnl5<-makeplot.param(my.trees5, burnin = 0, "LnL") # doesnt work if no '.p' file
lnl19<-makeplot.param(my.trees19, burnin = 0, "LnL") # doesnt work if no '.p' file
lnl003<-makeplot.param(my.trees003, burnin = 0, "LnL") # doesnt work if no '.p' file
lnl020<-makeplot.param(my.trees020, burnin = 0, "LnL") # doesnt work if no '.p' file
lnl020lcb<-makeplot.param(my.trees020LCB, burnin = 0, "LnL") # doesnt work if no '.p' file

lnl1$trace.plot$data

plot_lnl<-function(data,burnin,samplefreq){
dat=paste(data,'trace.plot','data',sep='$')
ggplot(eval(parse(text = dat)))+
  geom_line(aes(x=generation,y=LnL,color=chain))+
  geom_vline(xintercept = burnin*samplefreq)+
  scale_x_log10(labels = scales::number_format(), sec.axis = sec_axis(~.*1/samplefreq, name = "",labels = scales::number_format()))+facet_wrap(~chain, ncol=1)+guides(color=F)+theme(strip.placement = "top")
}

plot_lnl('lnl1',1000,10)
plot_lnl('lnl2',20,500)
plot_lnl('lnl3',200,500)
plot_lnl('lnl4',200,500)
plot_lnl('lnl5',10,10000)
plot_lnl('lnl19',1000,10)
plot_lnl('lnl003',100,1000)
plot_lnl('lnl020',10,10000)

# plot with burnin
makeplot.param(my.trees, burnin = 1100, "LnL") # doesnt work if no '.p' file
makeplot.param(salamanders.amotl, burnin = 50, "LnL")

makeplot.param(my.trees, burnin = 1100, "pi.A.")
makeplot.param(my.trees, burnin = 1100, "TL")

makeplot.param(my.trees1, burnin = 1000, "TL")
makeplot.param(my.trees2, burnin = 1100, "TL")
makeplot.param(my.trees3, burnin = 1100, "TL")
makeplot.param(my.trees4, burnin = 0, "TL")$trace.plot$data

plot_TL<-function(data,burnin,samplefreq){
dat=paste(data,'trace.plot','data',sep='$')
ggplot(eval(parse(text = dat)))+
  geom_line(aes(x=generation,y=TL,color=chain))+
  geom_vline(xintercept = burnin*samplefreq)+
  scale_x_continuous(labels = scales::number_format(), sec.axis = sec_axis(~.*1/samplefreq, name = "",labels = scales::number_format()))+facet_wrap(~chain, ncol=1)+guides(color=F)+theme(strip.placement = "top")
}

plot_TL('lnl1',1000,10)
plot_TL('lnl2',20,500)
plot_TL('lnl3',200,500)
plot_TL('lnl4',200,500)
plot_TL('lnl5',10,10000)
plot_TL('lnl19',1000,10)
```
# Split frequency plots

Are the chains exploring multiple optima (that may have the same likelyhood)?
Split frequency plots allow you to explore the behavior of posterior probability estimates as a function of chain length.

In an analysis that is mixing well, we expect the frequencies in the sliding window to move around a lot, but the frequencies in the cumulative plot should level off. If the frequencies in the cumulative plot have not levelled off, it might be necessary to run the chain for longer. Plots can be produced for single chains, or for multiple chains.


By default the plots show the 20 clades with the highest standard deviation of split frequencies within each sample (e.g. the standard deviation of the split frequencies of a given clade in a given chain, across all sliding windows). In an analysis that is mixing well, we expect the frequencies in the sliding window to move around a lot, but the frequencies in the cumulative plot should level off. If the frequencies in the cumulative plot have not levelled off, it might be necessary to run the chain for longer. Plots can be produced for single chains, or for multiple chains.

```{r}
makeplot.splitfreqs.cumulative(salamanders.amotl, burnin = 50)
makeplot.splitfreqs.sliding(salamanders.amotl, burnin = 50)

ssf1<-makeplot.splitfreqs.sliding(my.trees1, burnin = 1000)
ssf2<-makeplot.splitfreqs.sliding(my.trees2, burnin = 20)
ssf3<-makeplot.splitfreqs.sliding(my.trees3, burnin = 200)
ssf4<-makeplot.splitfreqs.sliding(my.trees4, burnin = 200)
ssf5<-makeplot.splitfreqs.sliding(my.trees5, burnin = 10)
ssf020<-makeplot.splitfreqs.sliding(my.trees020, burnin = 10)
  
sf0<-makeplot.splitfreqs.sliding(my.trees, burnin = 10000)
sf1<-makeplot.splitfreqs.cumulative(my.trees1, burnin = 1000)
sf2<-makeplot.splitfreqs.cumulative(my.trees2, burnin = 20)
sf3<-makeplot.splitfreqs.cumulative(my.trees3, burnin = 200)
sf4<-makeplot.splitfreqs.cumulative(my.trees4, burnin = 200)
sf5<-makeplot.splitfreqs.cumulative(my.trees5, burnin = 10)
sf020<-makeplot.splitfreqs.cumulative(my.trees020, burnin = 10)

```

```{r}
sfm1<-makeplot.splitfreq.matrix(my.trees1, burnin = 1000)
sfm2<-makeplot.splitfreq.matrix(my.trees2, burnin = 20)
sfm3<-makeplot.splitfreq.matrix(my.trees3, burnin = 200)
sfm4<-makeplot.splitfreq.matrix(my.trees4, burnin = 200)
sfm5<-makeplot.splitfreq.matrix(my.trees5, burnin = 10)
sfm020<-makeplot.splitfreq.matrix(my.trees020, burnin = 10)


sfm1$splitfreq.matrix
sfm2$splitfreq.matrix
sfm3$splitfreq.matrix
sfm4$splitfreq.matrix
sfm5$splitfreq.matrix
sfm020$splitfreq.matrix
```
##Sliding window and cumulative average change in split frequency (ACSF) plots
Ideally, we’d see the sliding window change in split frequencies remaining above zero but without big jumps (which would indicate the chain being stuck in one region of tree space, then moving to another), and we’d see the cumulative change in split frequencies approaching zero (indicating that the chain has settled on sampling from a single reqion of tree space, and that adding additional samples is not making any appreciable difference to the estimates of clade posterior probabilities one might make from the analysis).
```{r}
makeplot.asdsf(my.trees, burnin = 1100)+scale_x_log10()
makeplot.asdsf(salamanders.amotl, burnin=50)

acsfs1<-makeplot.acsf.sliding(my.trees1, burnin = 0)
acsfc1<-makeplot.acsf.cumulative(my.trees1, burnin = 0)

acsfs2<-makeplot.acsf.sliding(my.trees2, burnin = 0)
acsfc2<-makeplot.acsf.cumulative(my.trees2, burnin = 0)

acsfs3<-makeplot.acsf.sliding(my.trees3, burnin = 0)
acsfc3<-makeplot.acsf.cumulative(my.trees3, burnin = 0)

acsfs4<-makeplot.acsf.sliding(my.trees4, burnin = 0)
acsfc4<-makeplot.acsf.cumulative(my.trees4, burnin = 0)

acsfs5<-makeplot.acsf.sliding(my.trees5, burnin = 0)
acsfc5<-makeplot.acsf.cumulative(my.trees5, burnin = 0)

acsfs020<-makeplot.acsf.sliding(my.trees020, burnin = 10)
acsfc020<-makeplot.acsf.cumulative(my.trees020, burnin = 10)
acsfc020$acsf.cumulative.plot+scale_y_continuous(limits=c(0,1.0))

acsfc4$acsf.cumulative.plot$data


plot_acsf<-function(data,burnin,samplefreq){
eval(parse(text = data))+geom_vline(xintercept = burnin*samplefreq)+
    scale_y_sqrt()+
  scale_x_continuous(labels = scales::number_format(), sec.axis = sec_axis(~.*1/samplefreq, name = "",labels = scales::number_format()))}


plot_acsf('acsfc1$acsf.cumulative.plot',1000,10)
plot_acsf('acsfs1$acsf.sliding.plot',1000,10)

plot_acsf('acsfc2$acsf.cumulative.plot',20,500)
plot_acsf('acsfs2$acsf.sliding.plot',20,500)

plot_acsf('acsfc3$acsf.cumulative.plot',200,500)
plot_acsf('acsfs3$acsf.sliding.plot',200,500)

plot_acsf('acsfc4$acsf.cumulative.plot',200,500)
plot_acsf('acsfs4$acsf.sliding.plot',200,500)

plot_acsf('acsfc5$acsf.cumulative.plot',10,10000)+scale_y_continuous(limits=c(0,1))
plot_acsf('acsfs5$acsf.sliding.plot',10,10000)+scale_y_continuous(limits=c(0,1))

plot_acsf('acsfc020$acsf.cumulative.plot',10,10000)+scale_y_continuous(limits=c(0,1))
```

# Topology trace plots
In these plots, the y-axis represents the distance of each tree in the chain from the last tree of the burnin of the first chain. These plots can reveal whether the MCMC was sampling from a stationary distribution of chains (in which case it should be relative stable) or whether it is moving between modes (in which case you might see large jumps). They can also show how well the chain is mixing with respect to tree topologies. Well mixed chains will show the topology trace jumping rapidly between values. Poorly mixed chains will show chains remaining at similar values in successive samples. Topology traces can also reveal whether different chains are sampling different bits of tree space, in which case the stationary distrubtions will show traces at different y values on the plot. Finally, the topology trace contains an estimate of the ESS (called the approximate ESS) of tree topologies. Note that this estimate is only useful if the trees are sampled from a stationary distribution.

```{r}
makeplot.topology(salamanders.amotl, burnin = 50)

topo1<-makeplot.topology(my.trees1, burnin = 1000)
topo2<-makeplot.topology(my.trees2, burnin = 20)
topo3<-makeplot.topology(my.trees3, burnin = 200)
topo4<-makeplot.topology(my.trees4, burnin = 200)
topo5<-makeplot.topology(my.trees5, burnin = 10)
topo020<-makeplot.topology(my.trees020, burnin = 10)
topo003<-makeplot.topology(my.trees003, burnin = 1000)


plot_topotrace<-function(data,burnin,samplefreq){
dat=paste(data,'trace.plot','data',sep='$')
ggplot(eval(parse(text = dat)))+
  geom_line(aes(x=generation,y=topological.distance,color=chain))+
  geom_vline(xintercept = burnin*samplefreq)+
  scale_x_continuous(labels = scales::number_format(), sec.axis = sec_axis(~.*1/samplefreq, name = "",labels = scales::number_format()))+facet_wrap(~chain, ncol=1)+guides(color=F)+theme(strip.placement = "top")
}

plot_topotrace('topo1',1000,10)
plot_topotrace('topo2',20,500)
plot_topotrace('topo3',200,500)
plot_topotrace('topo4',200,500)
plot_topotrace('topo5',10,10000)
plot_topotrace('topo020',10,10000)
plot_topotrace('topo003',1000,10)
```


#Pairs plots
One of the new features of RWTY is that it allows us to look at correlations between tree topology and continuous model parameters via a “pairs plot”. These plots treat tree topology approximately like a continuous parameter, by calculating the distance of each tree from a focal tree.

```{r}

makeplot.pairs(salamanders.amotl, burnin=50, params = c("LnL", "pi.A.", "pi.C."))

```

There’s a lot to unpack in these plots, so here’s a quick rundown. Below the diagonal, we’ve got plots that show the movement of our chain in various combinations of tree and parameter space. For each plot, darker colors indicate generations earlier in the chain, and lighter colors indicate generations that are later. We can get a lot of information out of these plots. First off, they can tell us whether our overall estimate of the parameters were changing along the length of the chain (i.e., if we see darker points clustered together and lighter points clustered together). They can also tell us whether our estimates for a pair of parameters are correlated, which would be indicated by some overall slope to the pairwise plot (e.g. pi.A ae pi.C?).

On the diagonal, we have histograms indicataing the 95% CI for each parameter, and above the diagonal we have density plots for the relationship between two parameters. These are simply a replotting of the data below the diagonal, in a form that may be easier to process if you have a lot of generations in your chain.

Now let’s check out the fungus data.


```{r}
makeplot.pairs(fungus[[1]], burnin = 50, params = c("LnL", "pi.A.", "pi.C."))
```
Here we start to see just how informative these plots can be. Look at the bottom left corner, and you’ll see a plot of likelihood vs. topological distance from a focal tree. There’s a lot of information just in this plot about what our chain was doing. We can see that early on our chain was exploring one set of trees (darker points are separated from lighter points), but at some point it jumped to a different optimum that was farther from the focal tree (higher on the Y axis) and had a higher likelihood score (farther to the right on the X axis). Looking at the rest of the plots below the diagonal in the bottom row and in the left column shows that this jump to new topologies was not associated with any huge changes in parameter values for the model of molecular evolution; although the early and late points are separate along the topological distance and likelihood axes, the marginal distributions along the pi.A and pi.C axes are fairly similar. There might be a slight shift higher in pi.A with the shift to the new optimum and a slight shift lower in pi.C, but it’s not massive.

Now lets check my data
```{r}
makeplot.pairs(my.trees[[1]], burnin=50, params = c("LnL", "pi.A.", "pi.C."))

makeplot.pairs(my.trees[[1]], burnin=1100, params = c("LnL", "pi.A.", "pi.C."))
makeplot.pairs(my.trees[[1]], burnin=10000, params = c("LnL", "pi.A.", "pi.C."))


makeplot.pairs(my.trees4, burnin=200, params = c("LnL", "TL", "pi.C."))
makeplot.pairs(my.trees5, burnin=10, params = c("LnL", "pi.A.", "pi.C."))

```

# treespace plots
We can also visualize chains’ exploration of treespace using the treespace plotting functions in RWTY.

```{r}
makeplot.treespace(salamanders.amotl, burnin =50, fill.color = "LnL")
```
Okay, now we can see a lot more detail on the similarities between these two chains, and the coloring of the dot plots is more informative. From these plots it certainly looks like the chains are exploring the same area of tree space, albeit not in exactly the same frequency (i.e., chain 1 seems to be more heavily balanced towards the left side of our tree space and chain 2 the right side). This might argue for running these chains longer.

Notice that, although we’ve colored our circles in our dot plot by likelihood, it’s not clear that there’s any particular relationship between the likelihood (dot color) and the position in topology space. There are a couple of reasons this might be the case; first, these NMDS plots necessarily include a huge reduction in the dimensionality of the space being explored, and may put things close together in 2D space that are in fact fairly distinct along some axis that doesn’t weight heavily on those first two NMDS axes. Second, we’ve eliminated burnin here and are exploring one relatively contiguous optimum. That means that we will largely be exploring trees and parameter values that produce relatively similar likelihood estimates, so maybe we shouldn’t expect a whole lot of structure in whatever residual variation there is left.

Okay, let’s check out our fungus data.

```{r}
makeplot.treespace(fungus, burnin =50, fill.color = "LnL")
```

What’s going on with these heatmaps?

One thing to keep in mind here is that the density scaling is continuous across all plots. Apparently run 3 here has spent almost all of its time on a single tree, so it’s got one pixel of extremely high frequency. That squishes the scale of the other tree plots down to a point where you can’t really see what they’re doing at all. The dot plots are much more informative in this case, and they clearly show that all four of these chains are doing entirely different things. Given that they’re based on the same sequence data, this suggests that none of them should be trusted even if the individual chain plots (LnL trace, cumulative split frequency, etc.) look fine.

Since RWTY plots are ggplot2 objects, they have all the data required for plotting them stored within the plot itself. This is super handy if, say, you want to plot all of these chains on a single plot. Check it out:

```{r}
my.treespace <- makeplot.treespace(fungus, burnin =50, fill.color = "LnL")
qplot(x, y, data = my.treespace$treespace.points.plot$data, color = chain) +theme_bw()



```

Now let's try with my data

```{r}
makeplot.treespace(my.trees, burnin =10000, fill.color = "LnL")
my.treespace <- makeplot.treespace(my.trees, burnin =10000, fill.color = "LnL")
qplot(x, y, data = my.treespace$treespace.points.plot$data, color = chain) +theme_bw()


my.treespace1 <- makeplot.treespace(my.trees1, burnin =10000, fill.color = "LnL")
my.treespace1.1 <- makeplot.treespace(my.trees1[[1]], burnin =10000, fill.color = "LnL")
my.treespace1.2 <- makeplot.treespace(my.trees1[[2]], burnin =10000, fill.color = "LnL")
ggplot(data = my.treespace1$treespace.points.plot$data)+
  geom_hex(aes(x=x,y=y,color = chain,fill=..density..)) +theme_bw()+facet_wrap(~chain)



my.treespace2 <- makeplot.treespace(my.trees2, burnin =20, fill.color = "LnL")
my.treespace2.1 <- makeplot.treespace(my.trees2[[1]], burnin =20, fill.color = "LnL")
my.treespace2.2 <- makeplot.treespace(my.trees2[[2]], burnin =20, fill.color = "LnL")
qplot(x, y, data = my.treespace2$treespace.points.plot$data, color = chain) +theme_bw()
ggplot(data = my.treespace2$treespace.points.plot$data)+
  geom_hex(aes(x=x,y=y,color = chain,fill=..density..)) +theme_bw()+facet_wrap(~chain)


my.treespace3<-makeplot.treespace(my.trees3, burnin = 200, fill.color = "LnL")
ggplot(data = my.treespace3$treespace.points.plot$data)+
  geom_hex(aes(x=x,y=y,color = chain,fill=..density..)) +theme_bw()+facet_wrap(~chain)
qplot(x, y, data = my.treespace3$treespace.points.plot$data, color = chain) +theme_bw()


my.treespace4<-makeplot.treespace(my.trees4, burnin = 200, fill.color = "LnL") 
ggplot(data = my.treespace4$treespace.points.plot$data)+
  geom_hex(aes(x=x,y=y,color = chain,fill=..density..)) +theme_bw()+facet_wrap(~chain)

my.treespace5<-makeplot.treespace(my.trees5, burnin = 10, fill.color = "LnL") 
ggplot(data = my.treespace4$treespace.points.plot$data)+
  geom_hex(aes(x=x,y=y,color = chain,fill=..density..)) +theme_bw()+facet_wrap(~chain)


my.treespace003<-makeplot.treespace(my.trees003, burnin = 1000, fill.color = "LnL") 
ggplot(data = my.treespace003$treespace.points.plot$data)+
  geom_hex(aes(x=x,y=y,color = chain,fill=..density..)) +theme_bw()+facet_wrap(~chain)

my.treespace020<-makeplot.treespace(my.trees020LCB, burnin = 10, fill.color = "LnL") 
ggplot(data = my.treespace020$treespace.points.plot$data)+
  geom_hex(aes(x=x,y=y,color = chain,fill=..density..)) +theme_bw()+facet_wrap(~chain)


ggplot()+
   geom_hex(data=my.treespace2$treespace.points.plot$data,aes(x=x,y=-y,fill=..density..,color='tree2'))+facet_wrap(~chain)
ggplot()+
  geom_hex(data=my.treespace3$treespace.points.plot$data,aes(x=x,y=y,fill=..density..,color='tree3'))
ggplot()+
  geom_hex(data=my.treespace4$treespace.points.plot$data,aes(x=-x,y=y,fill=..density..,color='tree4'))+facet_wrap(~chain)


```

```{r}

```
# Autocorrelation
RWTY also produces plots that allow you to examine the autocorrelation between trees in your chain. Leaving heated chains aside for the moment, MCMC chains choose their next step in tree or model space based on where the chain is currently. That means there is necessarily some level of autocorrelation in the chain - subsequent trees are not necessarily random pulls from the stationary distribution of topologies. For this reason, it is typical to rarify the MCMC chain to reduce autocorrelation between trees. In a chain that has reached stationarity and that has been subsampled at appropriate intervals, subsequent trees would be no more correlated with each other than would trees randomly drawn from the chain. In other words, we would expect that correlation between trees would be uncorrelated with the distance between them. Autocorrelation plots allow us to examine these relationships.

```{R}
auto0<-makeplot.autocorr(salamanders, burnin = 0)
makeplot.autocorr(salamanders, burnin = 50)
```

These chains all look quite nice. Tree distance between pairs of trees is largely unaffected by the distance between them along the chain, indicating that the chains have potentially reached stationarity and that the sampling interval between trees is probably satisfactory. If chains had reached stationarity but the sampling interval were too small, we would see lower values for the mean path distance between trees at smaller sampling intervals, which would then increase toward a fixed value as sampling interval became large enough to overcome autocorrelation.

```{r}
makeplot.autocorr(fungus, burnin = 0)
?makeplot.autocorr
```

In chains that are far from stationarity, these plots will often show a general trend towards increasing path distance with increasing sampling interval that does not plateau, indicating that there is some overal trend in the chain towards directional movement in topology space. The absence of such a trend does not necessarily imply that convergence has been reached, but the presence of such a trend should always be cause for concern.

A well-mixed chain (in which sequential samples of tree topologies are effectively independent) will show flat lines on these plots. In a chain that is mixing poorly with respect to tree topologies, you will see the plot rising to an asymptote. This reflects the fact that are close to each other in the chain are more similar than trees that are further away, otherwise known as autocorrelation.


```{r}
?makeplot.autocorr
auto0<-makeplot.autocorr(my.trees, burnin = 1000)
auto1<-makeplot.autocorr(my.trees1, burnin = 1000)
auto2<-makeplot.autocorr(my.trees2, burnin = 20)
auto3<-makeplot.autocorr(my.trees3, burnin = 200)
auto4<-makeplot.autocorr(my.trees4, burnin = 200)
auto5<-makeplot.autocorr(my.trees5, burnin = 10)
auto19<-makeplot.autocorr(my.trees19, burnin = 1000,autocorr.intervals = 20)
auto020<-makeplot.autocorr(my.trees020, burnin = 10)
auto003<-makeplot.autocorr(my.trees003, burnin = 1000)

auto0.1<-makeplot.autocorr(my.trees, burnin = 1000,max.sampling.interval = 125)
auto0.2<-makeplot.autocorr(my.trees, burnin = 1000,max.sampling.interval = 50)

auto1.1<-makeplot.autocorr(my.trees1, burnin = 1000,max.sampling.interval = 100)
auto2.1<-makeplot.autocorr(my.trees2, burnin = 20,max.sampling.interval = 20)
auto3.1<-makeplot.autocorr(my.trees3, burnin = 200,max.sampling.interval = 20)
auto4.1<-makeplot.autocorr(my.trees4, burnin = 200,max.sampling.interval = 20)

auto0.1$autocorr.plot$data
auto1$autocorr.plot$data
auto2.1$autocorr.plot$data
auto3$autocorr.plot$data

topo_long<-makeplot.autocorr(my.trees, burnin = 10000)
str(topo_long)
qplot(sampling.interval, topo.distance, data = topo_long$autocorr.plot$data, color = chain,geom='line') +scale_x_continuous(limits=c(1,500))

makeplot.autocorr(my.trees, burnin = 0)

auto1$autocorr.plot+geom_vline(xintercept = 50, color='red',size=1)+scale_x_continuous(labels = scales::number_format(), sec.axis = sec_axis(~.*10, name = "generations"))

auto2$autocorr.plot+geom_vline(xintercept = 10000/500, color='green',size=1)+geom_vline(xintercept = 1, color='red',size=1)+scale_x_continuous(labels = scales::number_format(), sec.axis = sec_axis(~.*500, name = "generations"))

auto4$autocorr.plot+geom_vline(xintercept = 10000/500, color='green',size=0.5)+geom_vline(xintercept = 1, color='red',size=0.5)+scale_x_continuous(labels = scales::number_format(), sec.axis = sec_axis(~.*500, name = "generations"))

auto5$autocorr.plot+geom_vline(xintercept = 10000/10000, color='green',size=0.5)+geom_vline(xintercept = 1, color='red',size=0.5)+scale_x_continuous(labels = scales::number_format(), sec.axis = sec_axis(~.*10000, name = "generations"))

auto19$autocorr.plot+geom_vline(xintercept = 1000, color='green',size=0.5)+geom_vline(xintercept = 500, color='red',size=0.5)+scale_x_continuous(labels = scales::number_format(), sec.axis = sec_axis(~.*10, name = "generations"))

auto020$autocorr.plot+scale_y_continuous(limits=c(0,10))+scale_x_continuous(labels = scales::number_format(), sec.axis = sec_axis(~.*10000, name = "generations"))

auto003$autocorr.plot+scale_y_continuous(limits=c(0,10))+scale_x_continuous(labels = scales::number_format(), sec.axis = sec_axis(~.*10, name = "generations",labels = scales::number_format()))
```

# Pseudo-ESS plots

Another useful way of estimating the effects of autocorrelation on your MCMC chains is by calculating effective sample size. The math for doing this for continuous parameters is well-established, but it’s not possible to apply that approach directly to tree topologies. To deal with this, Lanfear et al. (2016) developed an approach based on looking at the ESS of distance from a focal tree. The pseudo-ESS plots produced by RWTY simply give confidence intervals for these estimates.

```{r}
makeplot.pseudo.ess(salamanders, burnin = 50)
makeplot.pseudo.ess(fungus, burnin = 50)


pess1<-makeplot.pseudo.ess(my.trees1, burnin = 1000,n = 5)
makeplot.pseudo.ess(my.trees2, burnin = 20)
makeplot.pseudo.ess(my.trees3, burnin = 200)
makeplot.pseudo.ess(my.trees4, burnin = 200)
makeplot.pseudo.ess(my.trees5, burnin = 10)
makeplot.pseudo.ess(my.trees020, burnin = 10)
pess020<-makeplot.pseudo.ess(my.trees020LCB, burnin = 10)$pseudo.ess.plot
sum(pess020$data[,c(2)])
```

As a general rule of thumb, it’s a good idea to have an ESS or pseudo-ESS of at least 200. As such we can be pretty happy about our salamander data, but not so much when it comes to the fungus data