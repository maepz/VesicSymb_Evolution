fisher.test(PleD_dupl3)
diversity(t(PleD_dupl3))  %>% mean(.)
Amplicons_meta$DedupInd<-ifelse(rownames(Amplicons_meta) == 'R13L-5-T_bis','R13L-5-T_bis',
ifelse(rownames(Amplicons_meta) == 'R16L-3-T_bis','R16L-3-T_bis', Amplicons_meta$Ind))
Amplicons_meta$Sample = rownames(Amplicons_meta)
head(Amplicons_meta)
str(Amplicons_meta)
LpxA_per_read_meta = merge(Amplicons_LpxA_per_read[,c('Sample','read_id.1')],Amplicons_meta[,c('Sample','Site','Ind','Region','Flow','dupl','chunk','DedupInd')], by='Sample', all.x=T)
rownames(LpxA_per_read_meta) = LpxA_per_read_meta$read_id.1
LpxA_per_read_meta$read_id.1 <- NULL
LpxA_per_read_meta %>% head
PleD_per_read_meta = merge(Amplicons_PleD_per_read[,c('Sample','read_id.1')],Amplicons_meta[,c('Sample','Site','Ind','Region','Flow','dupl','chunk','DedupInd')], by='Sample', all.x=T)
rownames(PleD_per_read_meta) = PleD_per_read_meta$read_id.1
PleD_per_read_meta$read_id.1 <- NULL
PleD_per_read_meta %>% head
LpxA=as.data.frame(Amplicons_LpxA_per_read[,'haplo'],row.names = row.names(Amplicons_LpxA_per_read))
colnames(LpxA)[1]='haplo'
LpxA %>% head
LpxA_obj <- df2genind(LpxA, ploidy=1,pop=factor(LpxA_per_read_meta$Sample), strata=LpxA_per_read_meta)
PleD=as.data.frame(Amplicons_PleD_per_read[,'haplo'],row.names = row.names(Amplicons_PleD_per_read))
colnames(PleD)[1]='haplo'
PleD %>% head
PleD_obj <- df2genind(PleD, ploidy=1,pop=factor(PleD_per_read_meta$Sample), strata=PleD_per_read_meta)
popsub(PleD_obj)
as.genclone(PleD_obj)
CB_MV=c('R13','R14','R15','R16')
MEF_samples = popNames(LpxA_obj)[!(popNames(LpxA_obj) %>% grepl(paste(CB_MV, collapse="|"),.))]
LpxA.MEF = popsub(LpxA_obj, sublist=MEF_samples)
PleD.MEF = popsub(PleD_obj, sublist=MEF_samples)
LpxA.MEF.amova = poppr.amova(LpxA.MEF,hier=~Flow/Ind/Sample,clonecorrect = FALSE,within=F,threads=4,method='ade4')
randtest(LpxA.MEF.amova, nrepet = 999)
PleD.MEF.amova = poppr.amova(PleD.MEF,hier=~Flow/Ind/Sample,clonecorrect = FALSE,within=F,threads=4,method='ade4')
randtest(PleD.MEF.amova, nrepet = 999)
PleD.MEF.amova
PleD.MEF.amova = poppr.amova(PleD.MEF,hier=~Flow/Ind/chunk/Sample,clonecorrect = FALSE,within=F,threads=4,method='ade4')
PleD.MEF.amova
PleD.MEF.amova = poppr.amova(PleD.MEF,hier=~Flow/Ind/Sample,clonecorrect = FALSE,within=F,threads=4,method='ade4')
PleD.MEF.amova
PleD.MEF.amova$results
variance_partitioning_dbRDA = function(fst,meta){
results=data.frame(level=character(), PropVariance=as.numeric(), Df=numeric(),SumofSquares=numeric(),F=numeric(),pval=numeric())
build_dbRDA_table = function(res){
lev1=as.character(strsplit(as.character(summary(res)$call)[2], " ")[[1]][3])
lev2=as.character(str_extract(as.character(summary(res)$call)[2], "(?<=\\()(.*?)(?=\\))"))
lev=as.character(paste(lev1,"within",lev2))
anova=anova.cca(res, by='terms',permu=1000)
df=anova$Df[1]
ss=anova$SumOfSqs[1]
F_=anova$F[1]
pval=anova$`Pr(>F)`[1]
summary(res)
table=as.data.frame(c(level=lev,
PropVariance=summary(res)$constr.chi/summary(res)$tot.chi,
Df=df,
SumofSquares=ss,
F=F_,
pval=pval)) %>% t(.)
rownames(table)=''
return(table)
}
PleD.MEF.amova
PleD.MEF.amova
quit
)
PleD.MEF.amova
build_results_table <- function(res) {
table=cbind(res$results,res$componentsofcovariance)
return(table)
}
build_results_table(PleD.MEF.amova)
PleD.MEF.amova
fix_phi_df <- function(df){
df1 <- arrange(df, -row_number())
rownames(df1) <- rev(rownames(df))
df1=rbind(df1,data.frame(row.names = 'Total',Phi = NA))
return(df1)
}
build_results_table <- function(res) {
table=cbind(res$results,res$componentsofcovariance,fix_phi_df$res$statphi)
return(table)
}
PleD.MEF.amova$statphi
build_results_table(PleD.MEF.amova)
fix_phi_df <- function(df){
df1 <- arrange(df, -row_number())
rownames(df1) <- rev(rownames(df))
df1=rbind(df1,data.frame(row.names = 'Total',Phi = NA))
return(df1)
}
build_results_table <- function(res) {
table=cbind(res$results,res$componentsofcovariance,fix_phi_df(res$statphi))
return(table)
}
PleD.MEF.amova$statphi
build_results_table(PleD.MEF.amova)
PleD.MEF.amova$statphi
build_results_table <- function(res) {
pval = randtest(res, nrepet =999)
pval = rbind(data.frame(P.value=rev(pval$pvalue),row.names = rev(pval$names)),data.frame(row.names = 'Total',P.value = NA))
table=cbind(res$results,res$componentsofcovariance,fix_phi_df(res$statphi))
return(table)
}
build_results_table <- function(res) {
pval = randtest(res, nrepet =999)
pval = rbind(data.frame(P.value=rev(pval$pvalue),row.names = rev(pval$names)),data.frame(row.names = 'Total',P.value = NA))
table=cbind(res$results,res$componentsofcovariance,fix_phi_df(res$statphi),pval)
return(table)
}
PleD.MEF.amova$statphi
build_results_table(PleD.MEF.amova)
build_results_table(LpxA.MEF.amova)
fix_phi_df <- function(df){
df1 <- arrange(df, -row_number())
rownames(df1) <- rev(rownames(df))
df1=rbind(df1,data.frame(row.names = 'Total',Phi = NA))
return(df1)
}
build_results_table <- function(res) {
pval = randtest(res, nrepet =999)
pval = rbind(data.frame(P.value=rev(pval$pvalue),row.names = rev(pval$names)),data.frame(row.names = 'Total',P.value = NA))
table=cbind(res$results,res$componentsofcovariance,pval,fix_phi_df(res$statphi))
return(table)
}
# randtest(LpxA.MEF.amova, nrepet = 999)
build_results_table(LpxA.MEF.amova)
LpxA.JdF.anova.region = poppr.amova(LpxA_obj,hier=~Region/Flow/DedupInd,clonecorrect = FALSE,within=TRUE,threads=4,method='ade4')
LpxA.JdF.anova.region
# randtest(LpxA.JdF.anova.region, nrepet = 999)
build_results_table(LpxA.JdF.anova.region)
PleD.JdF.anova.region = poppr.amova(PleD_obj,hier=~Region/Flow/DedupInd,clonecorrect = FALSE,within=TRUE,threads=4,method='ade4')
PleD.JdF.anova.region
# randtest(PleD.JdF.anova.region, nrepet = 999)
build_results_table(PleD.JdF.anova.region)
LpxA.JdF.anova.flow = poppr.amova(LpxA_obj,hier=~Flow/DedupInd,clonecorrect = FALSE,within=TRUE,threads=4,method='ade4')
LpxA.JdF.anova.flow
# randtest(LpxA.JdF.anova.flow, nrepet = 999)
build_results_table(LpxA.JdF.anova.flow)
# LpxA.JdF.anova.flow
# randtest(LpxA.JdF.anova.flow, nrepet = 999)
build_results_table(LpxA.JdF.anova.flow)
PleD.JdF.anova.flow = poppr.amova(PleD_obj,hier=~Flow/DedupInd,clonecorrect = FALSE,within=TRUE,threads=4,method='ade4')
# PleD.JdF.anova.flow
# randtest(PleD.JdF.anova.flow, nrepet = 999)
build_results_table(PleD.JdF.anova.flow)
MV = c('R15','R16')
END_samples = popNames(LpxA_obj)[!(popNames(LpxA_obj) %>% grepl(paste(MV, collapse="|"),.))]
LpxA_END = popsub(LpxA_obj, sublist=END_samples)
PleD_END = popsub(PleD_obj, sublist=END_samples)
LpxA.END.amova.region = poppr.amova(LpxA_END,hier=~Region/Flow/DedupInd,clonecorrect = FALSE,within=TRUE,threads=4,method='ade4')
LpxA.END.amova.region
randtest(LpxA.END.amova.region, nrepet = 999)
LpxA.END.amova.flow = poppr.amova(LpxA_END,hier=~Flow/DedupInd,clonecorrect = FALSE,within=TRUE,threads=4,method='ade4')
LpxA.END.amova.flow
randtest(LpxA.END.amova.flow, nrepet = 999)
PleD.END.amova.region = poppr.amova(PleD_END,hier=~Region/Flow/DedupInd,clonecorrect = FALSE,within=TRUE,threads=4,method='ade4')
PleD.END.amova.region
randtest(PleD.END.amova.region, nrepet = 999)
PleD.END.amova.flow = poppr.amova(PleD_END,hier=~Flow/DedupInd,clonecorrect = FALSE,within=TRUE,threads=4,method='ade4')
PleD.END.amova.flow
randtest(PleD.END.amova.flow, nrepet = 999)
MV = c('R15','R16')
END_samples = popNames(LpxA_obj)[!(popNames(LpxA_obj) %>% grepl(paste(MV, collapse="|"),.))]
LpxA_END = popsub(LpxA_obj, sublist=END_samples)
PleD_END = popsub(PleD_obj, sublist=END_samples)
LpxA.END.amova.region = poppr.amova(LpxA_END,hier=~Region/Flow/DedupInd,clonecorrect = FALSE,within=TRUE,threads=4,method='ade4')
# LpxA.END.amova.region
# randtest(LpxA.END.amova.region, nrepet = 999)
build_results_table(LpxA.END.amova.region)
# LpxA.END.amova.region
# randtest(LpxA.END.amova.region, nrepet = 999)
build_results_table(LpxA.END.amova.region)
LpxA.END.amova.flow = poppr.amova(LpxA_END,hier=~Flow/DedupInd,clonecorrect = FALSE,within=TRUE,threads=4,method='ade4')
# LpxA.END.amova.flow
# randtest(LpxA.END.amova.flow, nrepet = 999)
build_results_table(LpxA.END.amova.flow)
PleD.END.amova.region = poppr.amova(PleD_END,hier=~Region/Flow/DedupInd,clonecorrect = FALSE,within=TRUE,threads=4,method='ade4')
# PleD.END.amova.region
# randtest(PleD.END.amova.region, nrepet = 999)
build_results_table(PleD.END.amova.region)
PleD.END.amova.flow = poppr.amova(PleD_END,hier=~Flow/DedupInd,clonecorrect = FALSE,within=TRUE,threads=4,method='ade4')
# PleD.END.amova.flow
# randtest(PleD.END.amova.flow, nrepet = 999)
build_results_table(PleD.END.amova.flow)
setwd('~/Desktop/CRISPR_R/')
knitr::opts_chunk$set(echo = TRUE)
# install.packages("pegas")
# require(ape)
require(dplyr)
require(reshape2)
library('ggplot2')
require('ade4')
require('usedist')
setwd('/Users/maeva/Desktop/CRISPR_R/')
setwd('~/Desktop/CRISPR_R/')
.libPaths()
my.packages <- installed.packages()
save(my.packages, file = "listOfInstalledPackages.RData"
)
R.home()
system("type R")
file.path(R.home("bin"), "R")
version
setwd("/Users/maeperez/Desktop/VesicSymb_Evolution/dowstream_analyses_and_data")
# setwd("../CRISPR_haplo/")
library(dplyr)
library(reshape2)
library(tidyr)
library(ggplot2)
library(plotly)
require(reshape)
library(devtools)
prefix='a0.001'
nLCBs=793
pairs=read.table(paste0('./',prefix,'.pairs'),row.names=1)
pairs=read.table(paste0('../mauve_alignments/bucky_results/',prefix,'.pairs'),row.names=1)
head(pairs)
path_to_files='../mauve_alignments/bucky_results/'
pairs=read.table(paste0(path_to_files,prefix,'.pairs'),row.names=1)
head(pairs)
genes=read.table(paste0(path_to_files,prefix,'.input'),skip =2,nrows=nLCBs,sep="")
genes$V2<-strsplit(as.character(genes$V2),split="/") %>% sapply(., "[[", 2)
genes$V3<-gsub('.in','',genes$V2)
genes$V4<-substr(genes$V3,1,9)
colnames(genes)<-c('gene_no','file','nex','gene_id')
range_string = strsplit(genes$nex,split="_") %>% sapply(., "[[", 4)
genes$len<- as.numeric(strsplit(range_string,split="to") %>% sapply(., "[[", 2)) - as.numeric(strsplit(range_string,split="to") %>% sapply(., "[[", 1))
head(genes)
nrow(genes)
dat=genes
head(dat)
nrow(dat)
summary(dat)
ggplot(dat)+
geom_histogram(aes(x=len,y=..count..))+scale_x_log10()
x=readLines(paste0(path_to_files,prefix,'.gene'))
closeAllConnections()
start <- grep("^Gene", x)
mark <- vector('integer', length(x))
mark[start] <- 1
# determine limits of each table
mark <- cumsum(mark)
# mark<-mark[1:302]
# split the data for reading
df <- lapply(split(x, mark), function(.data){
.input <- read.table(textConnection(.data), skip=2, header=TRUE)
attr(.input, 'name') <- .data[1]  # save the name
.input})
# rename the list
names(df) <- sapply(df, attr, 'name')
maxtopo=setNames(data.frame(matrix(ncol = 5, nrow = 0)), c("index", "topology", "single", "joint",'gene_no'))
for(gene in names(df)){
gene_no=gsub('Gene ','',gene) %>% substr(.,1,nchar(.)-1)
subtable=as.data.frame(df[gene],col.names = '')
subtable=subtable[which.max(subtable$joint),] # looking for max prob in joint
subtable$gene_no=gene_no
maxtopo=rbind(maxtopo,subtable)
}
colnames(maxtopo)[1]='topo_index'
nrow(maxtopo)
table=merge(dat,maxtopo,by='gene_no',all.x=T)
head(table)
topo_len=aggregate(len~topo_index, table,FUN='sum')
totlen=sum(topo_len$len)
subset(table,topo_index<11)$gene_id %>% unique(.) # 265/888 LCBs (tot 297096 bp) are represented by the first 10 topologies.
topo_len
totlen=sum(topo_len$len)
totlen
table$topo_index %>% unique
aggregate(len~topo_index, table,FUN='sum',subset = subset(table,topo_index<11))
subset(table,topo_index<11)
aggregate(len~topo_index, table,FUN='sum',subset = subset(table,topo_index<11)$gene_id %>% unique(.))
aggregate(len~topo_index, table,FUN='sum',subset = topo_index<11))
aggregate(len~topo_index, table,FUN='sum',subset = topo_index<11)
subset(table,topo_index<11)$gene_id
aggregate(len~topo_index, table,FUN='sum',subset = gene_id %in% subset(table,topo_index<11)$gene_id %>% unique(.) )
aggregate(len~topo_index, table,FUN='sum',subset = gene_id %in% subset(table,topo_index<11)$gene_id %>% unique(.) )$len
aggregate(len~topo_index, table,FUN='sum',subset = gene_id %in% subset(table,topo_index<11)$gene_id %>% unique(.) )$len %>% sum
aggregate(len~topo_index, table,FUN='sum',subset = gene_id %in% subset(table,topo_index<11)$gene_id %>% unique(.) )$len %>% sum
totlen
most.common.trees=summary(as.factor(table$topo_index)) %>% sort(.,decreasing = T) %>% data.frame(.) # sort topologies by number of represented LCBs represented by them (decreasing order)
colnames(most.common.trees)[1]='LCB_count' # # of LCB with that topology
most.common.trees$topo_index=row.names(most.common.trees)
most.common.trees$pgen=most.common.trees$LCB_count/nLCBs #pgen= LCB relative abundance
most.common.trees=most.common.trees[c(rownames(most.common.trees)[-1],rownames(most.common.trees)[1]),] # Place the "Others" category at the end as it lumps all the rare topologies
most.common.trees$cumsum=cumsum(most.common.trees$pgen) # LCB cumulative abundance
most.common.trees$n_gen=as.numeric(seq(1,nrow(most.common.trees))) # continuous axis
most.common.trees=merge(topo_len,most.common.trees,by='topo_index',all.y=T)
most.common.trees[1,'len']=totlen-sum(most.common.trees[-1,'len'])
most.common.trees=most.common.trees[c(rownames(most.common.trees)[-1],rownames(most.common.trees)[1]),] # sort dataframe again
most.common.trees$plen=most.common.trees$len/totlen
most.common.trees= most.common.trees[order(most.common.trees$plen, decreasing = T),]
rowlist=c(rownames(subset(most.common.trees, topo_index != '(Other)')),
rownames(subset(most.common.trees, topo_index == '(Other)')))
most.common.trees=most.common.trees[rowlist,]
most.common.trees$plencumsum=cumsum(as.numeric(most.common.trees$plen))
most.common.trees=most.common.trees[order(most.common.trees$n_gen),]
N50=most.common.trees[most.common.trees$cumsum>0.5,][1,'n_gen']
N75=most.common.trees[most.common.trees$cumsum>0.75,][1,'n_gen']
qplot(x=n_gen,y=cumsum,data=most.common.trees)+
geom_vline(xintercept = N50, color='red',size=1)+
geom_vline(xintercept = N75, color='green',size=1)+
theme_bw() # 52 topologies are necessary to represent 75% of the LCBs, 19 topologies are necessary to represent 50% of the LCBs
N50
N75
most.common.trees= most.common.trees[order(most.common.trees$plencumsum),]
most.common.trees$n_len=seq(1,nrow(most.common.trees),)
most.common.trees=most.common.trees[order(most.common.trees$n_len),]
L50=most.common.trees[most.common.trees$plencumsum>0.5,][1,'n_len']
L75=most.common.trees[most.common.trees$plencumsum>0.75,][1,'n_len']
qplot(x=n_len,y=plencumsum,data=most.common.trees) # 31 topologies are necessary to represent 75% of the core genome length, 11 topologies are necessary to represent 50% of the core genome length
L50
L75
most.common.trees %>% head(LCB_count,n = 20)
qplot(x=plen,y=pgen,data=most.common.trees)+scale_y_log10()+scale_x_log10()
###
ggplot(subset(table, topo_index <5))+
geom_histogram(aes(x=topo_index+1))
table[,c('topology','topo_index')] %>% unique()
mat=as.matrix(pairs)
# set column names to gene IDs. Actual gene names would be best...
colnames(mat) = rownames(mat)
mat # Just to check. Big! 100x100 matrix
diag(mat) # check that diagonal has ones only.
# now NMDS calculations:
mds = cmdscale(1-mat)
str(mds) # matrix of 100 rows and 2 columns: for the 2 axes.
plot(mds[,1], mds[,2], type="n", xlab="axis 1", ylab="axis 2",
asp=1, # to keep aspect ratio = 1 between both axes
main="dissimilarity between genes: P{Ti and Tj differ}")
text(mds[,1], mds[,2], rownames(mds), cex=0.6)
head(mds)
mds=cbind(mds,table)
colnames(mds)[1]='NMDS1'
colnames(mds)[2]='NMDS2'
head(mds)
### Good plot ####
ggplot()+
geom_point(data=subset(mds,topo_index>19),aes(x=NMDS1,y=NMDS2),color='black',size=1,alpha=0.5)+
geom_point(data=subset(mds,topo_index<20),aes(x=NMDS1,y=NMDS2,color=as.factor(topo_index)),size=1,alpha=1)
#Distribution of genes with tree 0,1 and 2
subset(mds,NMDS1>0.3)$topo_index
plot(x=subset(mds,NMDS1>0.3)$gene_id %>% strsplit(.,split = '_') %>% sapply(., "[[", 2)  %>% as.integer(.) ,y=rep(1,length(subset(mds,NMDS1>0.3)$gene_id)),type = 'h')
#Distribution of genes with tree 0
subset(mds,topo_index==0)$topo_index
plot(x=subset(mds,topo_index==0)$gene_id %>% strsplit(.,split = '_') %>% sapply(., "[[", 2)  %>% as.integer(.) ,y=rep(1,length(subset(mds,topo_index==0)$gene_id)),type = 'h')
# distribution of all gene trees
par(mfrow = c(5, 2))
for(topo in subset(mds,topo_index<20)$topo_index %>% unique(.) %>% sort(.)){
plot(x=subset(mds,topo_index==topo)$gene_id %>% strsplit(.,split = '_') %>% sapply(., "[[", 2)  %>% as.integer(.) ,y=rep(1,length(subset(mds,topo_index==topo)$gene_id)),type = 'h',xlab='',ylab='',sub=paste('topology', topo),ylim=c(0,1))
}
for(topo in subset(mds,topo_index<20)$topo_index %>% unique(.) %>% sort(.)){
plot(x=subset(mds,topo_index==topo)$gene_id %>% strsplit(.,split = '_') %>% sapply(., "[[", 2)  %>% as.integer(.) ,y=rep(1,length(subset(mds,topo_index==topo)$gene_id)),type = 'h',xlab='',ylab='',sub=paste('topology', topo),ylim=c(0,1))
}
# distribution of all gene trees
par(mfrow = c(5, 2))
for(topo in subset(mds,topo_index<20)$topo_index %>% unique(.) %>% sort(.)){
plot(x=subset(mds,topo_index==topo)$gene_id %>% strsplit(.,split = '_') %>% sapply(., "[[", 2)  %>% as.integer(.) ,y=rep(1,length(subset(mds,topo_index==topo)$gene_id)),type = 'h',xlab='',ylab='',sub=paste('topology', topo),ylim=c(0,1))
}
### Good plot ####
ggplot()+
geom_point(data=subset(mds,topo_index>19),aes(x=NMDS1,y=NMDS2),color='black',size=1,alpha=0.5)+
geom_point(data=subset(mds,topo_index<20),aes(x=NMDS1,y=NMDS2,color=as.factor(topo_index)),size=1,alpha=1)
mat=as.matrix(pairs)
# set column names to gene IDs. Actual gene names would be best...
colnames(mat) = rownames(mat)
mat # Just to check. Big! 100x100 matrix
diag(mat) # check that diagonal has ones only.
# now NMDS calculations:
mds = cmdscale(1-mat)
str(mds) # matrix of 100 rows and 2 columns: for the 2 axes.
plot(mds[,1], mds[,2], type="n", xlab="axis 1", ylab="axis 2",
asp=1, # to keep aspect ratio = 1 between both axes
main="dissimilarity between genes: P{Ti and Tj differ}")
text(mds[,1], mds[,2], rownames(mds), cex=0.6)
head(mds)
mds=cbind(mds,table)
colnames(mds)[1]='NMDS1'
colnames(mds)[2]='NMDS2'
head(mds)
### Good plot ####
ggplot()+
geom_point(data=subset(mds,topo_index>19),aes(x=NMDS1,y=NMDS2),color='black',size=1,alpha=0.5)+
geom_point(data=subset(mds,topo_index<20),aes(x=NMDS1,y=NMDS2,color=as.factor(topo_index)),size=1,alpha=1)
setwd("/Users/maeperez/Desktop/VesicSymb_Evolution/dowstream_analyses_and_data")
# setwd("../CRISPR_haplo/")
library(dplyr)
library(reshape2)
library(tidyr)
library(ggplot2)
library(plotly)
require(reshape)
library(devtools)
mat=as.matrix(pairs)
# set column names to gene IDs. Actual gene names would be best...
colnames(mat) = rownames(mat)
mat # Just to check. Big! 100x100 matrix
diag(mat) # check that diagonal has ones only.
# now NMDS calculations:
mds = cmdscale(1-mat)
str(mds) # matrix of 100 rows and 2 columns: for the 2 axes.
plot(mds[,1], mds[,2], type="n", xlab="axis 1", ylab="axis 2",
asp=1, # to keep aspect ratio = 1 between both axes
main="dissimilarity between genes: P{Ti and Tj differ}")
text(mds[,1], mds[,2], rownames(mds), cex=0.6)
head(mds)
mds=cbind(mds,table)
colnames(mds)[1]='NMDS1'
colnames(mds)[2]='NMDS2'
head(mds)
### Good plot ####
ggplot()+
geom_point(data=subset(mds,topo_index>19),aes(x=NMDS1,y=NMDS2),color='black',size=1,alpha=0.5)+
geom_point(data=subset(mds,topo_index<20),aes(x=NMDS1,y=NMDS2,color=as.factor(topo_index)),size=1,alpha=1)
as.factor(topo_index)
mds
ggplot()+
geom_point(data=subset(mds,topo_index>19),aes(x=NMDS1,y=NMDS2),color='black',size=1,alpha=0.5)
ubset(mds,topo_index>19)
subset(mds,topo_index>19)
### Good plot ####
ggplot()+
geom_point(data=subset(mds,topo_index>19),aes(x=NMDS1,y=NMDS2),color='black',size=1,alpha=0.5)
### Good plot ####
dev.off()
ggplot()+
geom_point(data=subset(mds,topo_index>19),aes(x=NMDS1,y=NMDS2),color='black',size=1,alpha=0.5)+
geom_point(data=subset(mds,topo_index<20),aes(x=NMDS1,y=NMDS2,color=as.factor(topo_index)),size=1,alpha=1)
subset(mds,topo_index==7)
subset(mds,topo_index==7)$topology %>% unique
subset(mds,topo_index==0)$topology %>% unique
head(genes)
subset(mds,topo_index==1)$topology %>% unique #Rmag sister to plio,recti and V.gigas basal of Clade I
subset(mds,topo_index==9)$topology %>% unique
#Distribution of genes with tree 0 and 1
subset(mds,NMDS1>0.3)$topo_index
plot(x=subset(mds,NMDS1>0.3)$gene_id %>% strsplit(.,split = '_') %>% sapply(., "[[", 2)  %>% as.integer(.) ,y=rep(1,length(subset(mds,NMDS1>0.3)$gene_id)),type = 'h')
subset(mds,topo_index==0)$topo_index
plot(x=subset(mds,topo_index==0)$gene_id %>% strsplit(.,split = '_') %>% sapply(., "[[", 2)  %>% as.integer(.) ,y=rep(1,length(subset(mds,topo_index==0)$gene_id)),type = 'h')
# is this random?
?plot
subset(mds,topo_index==1)$topo_index
plot(x=subset(mds,topo_index==1)$gene_id %>% strsplit(.,split = '_') %>% sapply(., "[[", 2)  %>% as.integer(.) ,y=rep(1,length(subset(mds,topo_index==1)$gene_id)),type = 'h')
# is this random?
?plot
subset(mds,topo_index==1)$topo_index
plot(x=subset(mds,topo_index==1)$gene_id %>% strsplit(.,split = '_') %>% sapply(., "[[", 2)  %>% as.integer(.) ,y=rep(1,length(subset(mds,topo_index==1)$gene_id)),type = 'h')
subset(mds,topo_index==7)$topo_index
plot(x=subset(mds,topo_index==7)$gene_id %>% strsplit(.,split = '_') %>% sapply(., "[[", 2)  %>% as.integer(.) ,y=rep(1,length(subset(mds,topo_index==7)$gene_id)),type = 'h')
plot(x=subset(mds,topo_index==9)$gene_id %>% strsplit(.,split = '_') %>% sapply(., "[[", 2)  %>% as.integer(.) ,y=rep(1,length(subset(mds,topo_index==9)$gene_id)),type = 'h')
mat=as.matrix(pairs)
# set column names to gene IDs. Actual gene names would be best...
colnames(mat) = rownames(mat)
mat # Just to check. Big! 100x100 matrix
diag(mat) # check that diagonal has ones only.
test=as.dist(1-mat)
is.euclid(test)
is.euclid(sqrt(test))
# PcoA
cmdscale(sqrt(1-mat)) %>% plot(.)
wcmdscale(sqrt(1-mat)) %>% plot(.)
prcomp(sqrt(1-mat)) %>% plot(.)
prcomp(sqrt(1-mat)) %>% summary(.)
library(ape)
PCOA=pcoa(sqrt(test),correction = "cailliez")
barplot(PCOA$values$Relative_eig)
biplot(pcoa)
pcoa1=cmdscale(sqrt(1-mat),k=3,eig=T )
pcoa1$GOF
pcoa1$eig[1]/sum(pcoa1$eig)
pcoa1$eig[2]/sum(pcoa1$eig)
pcoa1$eig[3]/sum(pcoa1$eig)
(pcoa1$eig[1]+pcoa1$eig[2])/sum(pcoa1$eig) # axes 1 and 2 explain 10% of variation
(pcoa1$eig[1]+pcoa1$eig[2]+pcoa1$eig[3])/sum(pcoa1$eig)
pcoa1$points %>% plot(.)
pcoa=cbind(pcoa1$points,table)
colnames(pcoa)[1]='PcoA1'
colnames(pcoa)[2]='PcoA2'
colnames(pcoa)[3]='PcoA3'
head(pcoa)
### Good plot ####
ggplot()+
geom_point(data=subset(pcoa,!(topo_index %in% c('0','1','4','6','9'))),aes(x=PcoA1,y=PcoA2,color='all others'),color='black',size=1,alpha=0.5)+
geom_point(data=subset(pcoa,topo_index %in% c('0','1','4','6','9')),aes(x=PcoA1,y=PcoA2,color=as.factor(topo_index)),size=1,alpha=1)
plot_ly(data=subset(pcoa,topo_index %in% c('0','1','4','6','9','12','22')),x=~PcoA1,y=~PcoA2,z=~PcoA3,color=~as.factor(topo_index),size=1)
par(mfrow=c(1,1))
ggplot(mds)+geom_histogram(aes(x=topo_index+0.01),binwidth = 10)+scale_y_log10()
summary(as.factor(mds$topo_index)) %>% sort(.,decreasing = T) %>% plot(.,ylab='genes with that topology',xlab='topologies')
MLtrees=summary(as.factor(mds$topo_index)) %>% sort(.,decreasing = T) %>% data.frame(.)
MLtrees=merge(unique(mds[,c('topo_index','topology')]),aggregate(mds[,c('topo_index','single','joint')],by=list(mds$topo_index),FUN = mean),by='topo_index',all.y=T) %>% .[,-3] %>% cbind(.,summary(as.factor(mds$topo_index)) %>% data.frame(.))
colnames(MLtrees)[3]='mean_single'
colnames(MLtrees)[4]='mean_joint'
colnames(MLtrees)[5]='gene_counts'
write.table(MLtrees,'MLtrees_genes20.txt',sep='\t',quote = F,row.names = F)
MLtrees$gene_counts %>% sum(.)/2
##########
most.freq.trees=summary(as.factor(mds$topo_index)) %>% sort(.,decreasing = T) %>% data.frame(.) %>% rownames(.)
most.freq.trees=most.freq.trees[1:8]
ggplot(subset(mds,topo_index %in% most.freq.trees))+
geom_vline(aes(xintercept=gene_id %>% strsplit(.,split = '_') %>% sapply(., "[[", 2)  %>% as.integer(.),color=as.factor(topo_index)))+scale_color_brewer(palette='Dark2')
ggplot(subset(mds,topo_index %in% most.freq.trees))+
geom_vline(aes(xintercept=gene_id %>% strsplit(.,split = '_') %>% sapply(., "[[", 2)  %>% as.integer(.),color=SEED_level_1))+facet_wrap(~topo_index)
### Good plot ####
most.common.trees10=most.common.trees[1:10]
### Good plot ####
most.common.trees10=most.common.trees[1:10]
most.common.trees
### Good plot ####
most.common.trees10=most.common.trees[1:10,'topo_index']
ggplot()+
geom_point(data=subset(mds,!(topo_index %in% most.common.trees10)),aes(x=NMDS1,y=NMDS2),color='black',size=1,alpha=0.5)+
geom_point(data=subset(mds,topo_index %in% most.common.trees10),aes(x=NMDS1,y=NMDS2,color=as.factor(topo_index)),size=1,alpha=1)
subset(mds,topo_index=='6' & selected=='yes')
